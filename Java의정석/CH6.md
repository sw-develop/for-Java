# ✔️ 객체지향언어   
## ▶️ 주요 특징
- 코드의 재사용성이 높다.
- 코드의 관리가 용이하다.   
- 신뢰성이 높은 프로그래밍을 가능하게 한다.
    - 제어자와 메서드를 이용해 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거 가능하다.
   
### 💡 공부하는 관점
- 너무 객체지향개념에 얽매여서 고민하기 보다 일단 프로그램을 기능적으로 완성한 뒤 객체지향적으로 코드를 개선해나가면 된다.
- 처음부터 이론을 많이 안다고 해서 좋은 설계를 할 수 있는 것은 아니다.


# ✔️ 클래스와 객체
#### ▶️ 클래스와 객체의 정의와 용도
- 클래스: 객체를 정의해 놓은 것
- 객체: 클래스에 정의된 내용대로 메모리에 생성된 것

#### ▶️ 객체와 인스턴스
- 클래스의 인스턴스화: 클래스로부터 객체를 만드는 과정
- 인스턴스와 객체는 같은 의미이다.

#### ▶️ 객체의 구성요소 - 속성과 기능
- 클래스 = 멤버변수 + 메서드
- 클래스에는 객체의 모든 속성과 기능이 정의되어있다.

#### ▶️ 인스턴스의 생성과 사용
```java
클래스명 변수명; //A
변수명 = new 클래스명(); //B
```
- A: 클래스의 객체를 참조하기 위한 참조변수를 선언 → 메모리에 참조변수를 위한 공간이 마련됨   
- B: 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장 → 인스턴스가 메모리의 빈 공간에 생성됨, 멤버변수는 각 자료형에 해당하는 기본값으로 초기화됨   


- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.
- 참조변수에 의해 참조되지 않는 인스턴스는 '가비지 컬렉터'에 의해 자동적으로 메모리에서 제거된다.

# ✔️ 변수와 메서드
## ▶️ 선언 위치에 따른 변수의 종류  

|변수의 종류|선언위치|생성시기|
|------|---|---|
|클래스 변수(멤버 변수)|클래스 영역|클래스가 메모리에 올라갈 떄|
|인스턴스 변수(멤버 변수)|클래스 영역|인스턴스가 생성되었을 때|
|지역 변수|클래스 영역 이외의 영역 (메서드, 생성자, 초기화 블럭 내부)|변수 선언문이 수행되었을 때|

- 인스턴스 변수
  - 인스턴스는 독립적인 저장공간을 가지므로, 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수로 선언한다.
- 클래스 변수
  - 인스턴스 변수 앞에 static을 붙여 선언한다.
  - 클래스 변수는 모든 인스턴스가 공통된 저장공간(변수)을 공유한다.
  - 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야 하는 속성의 경우, 클래스 변수로 선언한다.
  - **클래스가 메모리에 '로딩(loading)'될 때 생성되어 프로그램이 종료될 때까지 유지된다.**
  - public을 앞에 붙이면 '전역변수(global variable)'의 성격을 갖는다.

## ▶️ 메서드의 return문
- 메서드의 반환값의 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야 한다.
- 메서드의 반환타입이 void인 경우, return문 없이도 아무런 문제가 없었던 이유는 컴파일러가 메서드의 마지막에 "return;"을 자동적으로 추가해주었기 때문이다.

## ▶️ 매개변수의 유효성 검사
- 메서드 작성시 '호출하는 쪽에서 알아서 적절한 값을 넣겨주겠지'라는 생각을 절대로 가져서는 안 된다.
- 가능한 모든 입력값의 경우의 수에 대해 고민하고 그에 대비한 코드를 작성해야 한다.

## ▶️ JVM의 메모리 구조
- 응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당바고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.
- 주요 영역: Method Area, Call Stack, Heap

### #️⃣ 메서드 영역(Method Area)
- 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스 파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 해당 영역에 저장한다.
- 해당 클래스의 클래스 변수도 동일한 영역에 함께 생성된다.

### #️⃣ 힙(Heap)
- 인스턴스가 생성되는 공간이다.
- 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 저장된다. 
- 인스턴스 변수들이 생성되는 공간이다.

### #️⃣ 호출스택(Call Stack or Execution Stack)
- 메서드의 작업에 필요한 메모리 공간을 제공한다. --> 각 메서드를 위한 메모리상의 작업공간은 서로 구별된다.
- 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다.
- 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워진다.
- 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드이다.
- 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.

## ▶️ 기본형 vs. 참조형 매개변수
- 기본형 매개변수 
  - 변수의 전달된 값을 읽기만 할 수 있다. (read only)
  - 원본 변수의 값을 변경할 수는 없다는 의미, 원본이 아닌 복사본이 변경된 것
- 참조형 매개변수 
  - 전달된 변수의 값을 읽고 변경할 수 있다. (read & write) 
  - 매개변수가 참조형이라서 값이 아니라 '값이 저장된 주소'를 전달한 것, 서로 다른 참조변수가 동일한 인스턴스를 참조하고 있음

## ▶️ 참조형 반환타입
- 메서드의 반환타입이 '참조형'이라는 것 == 메서드가 '객체의 주소'를 반환한다는 것

## ▶️ 재귀호출(recursive call)
- 재귀호출의 주의점
  - 반복문은 그저 같은 문장을 반복해서 수행하는 것이지만, **메서드를 새로 호출하는 것은 매개변수 복사, 종료 후 복귀할 주소저장, 메서드 수행을 위한 새로운 메모리 공간 할당 등이 추가**로 필요하기 때문에 반복문보다 재귀호출의 수행시간이 더 오래 걸린다.
  - 재귀호출은 비효율적이므로 재귀호출에 드는 비용 << 재귀호출의 간결함이 주는 이점이 충분히 큰 경우에만 사용해야 한다!
  - 재귀호출로 인해 메서드의 작업 수행을 위한 메모리공간이 계속해서 할당이 되면 호출스택 영역의 '스택오버플로우 에러'가 발생할 수 있다.

## ▶️ 클래스 메서드와 인스턴스 메서드
- 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통된 값으로 사용하는 것에 static을 붙인다. (클래스 변수로 생성)
- 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
- 클래스 메서드는 메서드의 구현부에서 인스턴스 변수와 인스턴스 메서드를 사용할 수 없다.
  - 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다.
  
- 메서드 내에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는다면, static을 붙이는 것을 고려한다.
  - **💡메서드 호출시간이 짧아지므로 성능이 향상된다.** 
      - 클래스 변수와 클래스 메서드는 클래스가 메모리에 생성될 때 같이 생성되므로, 딱 한 번만(한 개만) 생성되기 떄문이다.
  - 인스턴스 메서드 호출 시에는 호출되어야할 메서드를 찾는 과정이 추가적으로 필요하기 때문에 시간이 더 걸린다. 
      - 인스턴스는 여러 개가 생성되므로, 호출하고자 하는 메서드가 어떤 인스턴스의 메서드인지 찾아야 하기 때문이다.

# ✔️ 오버로딩(Overloading)
- 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메서드 오버로딩'이라고 한다.
## ▶️ 오버로딩의 조건
- 메서드 이름이 같아야 한다.
- 매개변수의 개수 or 타입이 달라야 한다.
  - 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.
  
## ▶️ 가변인자(varargs)와 오버로딩
- 가변인자: 기존에는 메서드의 매개변수 개수가 고정적이었으나, JDK1.5부터 동적으로 지정해 줄 수 있게 되었다.
```java
public PrintStream printf(String formant, Object... args) {...}
```
- '타입... 변수명' 형식으로 선언한다.
- PrintStream 클래스의 printf()가 대표적인 예이다.
- 위와 같이 가변인자 외에도 매개변수가 더 있다면, 가변인자는 매개변수 중에서 가장 마지막에 선언해야 한다. (아니면, 컴파일 에러 발생)

### #️⃣️ 가변인자의 장점 vs. 단점
### 장점
- 가변인자를 사용하면 메소드 오버로딩 대신 메서드를 하나로 간단히 대체할 수 있다. (ex. 여러 문자열을 하나로 결합하여 반환하는 메서드)
   
### 단점
- 가변인자는 내부적으로 배열을 이용한다.
- 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성되므로, 많이 사용하면 비효율적이다.

### #️⃣ 가변인자 vs. 매개변수의 타입을 배열로 하는 것과의 차이점
```java
//가변인자가 메서드의 매개변수
String concatenate(String... str) {...}

concatenate();
concatenate("a");
concatenate(new String[]{"A", "B"});

//매개변수의 타입이 배열
String concatenate(String[] str) {...}

concatenate();  //에러, 인자 필요
concatenate(null);
concatenate(new String[0]);
```
- 매개변수의 타입을 배열로 하면, 반드시 인자를 지정해 줘야하기 때문에, 인자 생략이 불가능하다. (null이나 길이가 0인 배열을 인자로 지정해줘야 하는 불편함)

### #️⃣ 가변인자를 선언한 메서드 오버로딩
- 오버로딩된 메서드 호출 시 구별하지 못하는 경우가 발생하기 쉽기 때문에 주의해야 한다.
- 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.

# ✔️ 생성자(Constructor)
- 생성자는 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다.
- 인스턴스 변수의 초기화, 인스턴스 생성 시에 실행되어야 할 작업을 위해 사용된다.

### #️⃣ 생성자의 조건
- 생성자의 이름은 클래스의 이름과 같아야 한다.
- 생성자는 리턴 값이 없다.
  - 생성자도 메서드이기 때문에 리턴값이 없다는 의미의 void를 붙여야 하지만, 모든 생성자가 리턴값이 없으므로 void를 생략할 수 있게 한 것이다.
  
### #️⃣ 수행 과정 예시
```java
Card c = new Card();
```
- 연산자 new에 의해 메모리(heap)에 Card 클래스의 인스턴스가 생성된다.
- 생성자 Card()가 호출되어 수행된다.
- 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.

## ▶️ 기본 생성자(default constructor)
- 모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 한다.
- 컴파일할 때, 소스파일(.java)의 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 기본 생성자를 추가하여 컴파일 한다.
```java
class Card {
  ...
  Card() {}  //기본 생성자
}
```
- 기본 생성자가 컴파일러에 의해 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.

## ▶️ 생성자에서 다른 생성자 호출하기 - this(), this
- 생성자간 호출을 위한 조건
  - 생성자의 이름으로 클래스이름 대신 this를 사용한다.
  - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
    - 다른 생성자 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문이다.
  
- this
  - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다.
  - 모든 인스턴스메서드에 지역변수로 숨겨진 채로 존재한다.
  
- this(), this(매개변수)
  - 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.

### 💡 인스턴스 생성 시 결정해야할 사항
- 클래스 - 어떤 클래스의 인스턴스를 생성할 것인가?
- 생성자 - 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가?