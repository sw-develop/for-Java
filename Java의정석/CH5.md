# ✔️ 배열(array)
- 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 '배열'이라고 한다.
- 변수와 달리 배열은 각 저장공간이 연속적으로 배치되어 있다.

## 💡 배열의 선언과 생성
```java
타입[] 변수이름 = new 타입[길이];
```
- 배열을 선언한 후 배열을 생성해야 한다.
- 배열을 선언하는 것은 단지 생성된 배열을 다루기 위한 참조변수를 위한 공간이 만들어질 뿐, 배열을 생성해야만 비로소 값을 저장할 수 있는 공간이 만들어진다.
- 연산자 'new'에 의해 메모리의 빈 공간에 데이터를 저장할 수 있는 공간이 마련된다.
- 각 배열 요소는 자동적으로 타입의 기본값으로 초기화 된다.

## 💡 배열의 인덱스와 길이
▶️ 인덱스
- 배열의 인덱스(index)의 범위는 0 ~ '배열길이-1'까지
- 유효하지 않은 값을 인덱스로 사용하면, 컴파일을 마쳤더라도 실행 시에 에러(ArrayIndexOutOfBoundsException)가 발생한다.
    - 컴파일러는 이러한 실수를 걸러주지 못한다.
    - 배열의 인덱스로 변수를 많이 사용하는데, 변수의 값은 실행 시에 대입되므로 컴파일러는 이 값의 범위를 확인할 수 없다.
    
▶️ 길이
- 배열의 길이는 배열의 요소의 개수, 즉 값을 저장할 수 있는 공간의 개수이다.
- 배열의 길이는 int 범위의 양의 정수(0 포함)이어야 한다. (길이가 0인 배열도 생성 가능함)
- 자바에서는 JVM이 모든 배열의 길이를 별도로 관리한다.
- 배열은 한번 생성하면 길이를 변경할 수 없기 때문에, '배열.length'는 상수이다. (값을 읽을 수만 있고, 변경 불가능)
- 배열의 길이를 변경하는 방법
    1. 길이가 더 큰 배열을 새로 생성한다.
    2. 기존 배열의 내용을 새로운 배열에 복사한다.   
    → 이러한 작업은 비용이 많이 들기 때문에, 처음부터 배열의 길이를 넉넉하게 잡아 새로 배열을 생성하는 상황이 가능한 적게 발생하도록 해야 한다.   
→ 기존의 2배정도의 길이로 생성하는 것이 좋다.
       
## 💡 배열의 초기화
- 배열을 초기화하는 방법
```java
//배열의 선언과 동시에 초기화
int[] score = new int[]{1, 2, 3, 4, 5};
int[] score = {1, 2, 3, 4, 5};  //배열의 선언과 동시에 초기화하는 경우에만 'new 타입[]'을 생략할 수 있음

//배열의 선언과 생성을 따로
int[] score;
score = new int[]{1, 2, 3, 4, 5};
score = {1, 2, 3, 4, 5};  //에러, 'new int[]' 생략 불가
```
- 길이가 0인 배열
```java
//길이가 0인 배열
int[] score = new int[0];
int[] score = new int[]{};
int[] score = {};
```
→ 참조변수의 기본 값은 null이지만, 배열을 가리키는 참조변수는 null 대신 길이가 0인 배열로 초기화하기도 한다.

## 💡 배열의 복사
### ▶️ for문을 이용해 배열 복사
```java
int[] arr = new int[5];
...
int[] tmp = new int[arr.length * 2];  //기존 배열보다 길이가 2배인 배열 생성

for(int i = 0; i < arr.length; i++) {
  tmp[i] = arr[i];
}

arr = tmp;  //참조변수 arr이 새로운 배열을 가리키게 한다.
```
- 배열은 참조변수를 통해서만 접근할 수 있기 때문에, 자신을 가리키는 참조변수가 없는 배열은 사용할 수 없다.
- 쓸모없게 된 배열은 JVM의 가비지 컬렉터에 의해서 자동적으로 메모리에서 제거된다.

### ▶️ System.arraycopy()를 이용한 배열 복사
- 배열의 복사는 System.arraycopy()를 사용하는 것이 간단하고 빨라 효율적이다.
- for문은 배열의 요소 하나하나에 접근해서 복사하지만, System 클래스의 arraycopy()는 지정된 범위의 값들을 한 번에 통째로 복사한다.
  - 각 요소들이 연속적으로 저장되어 있다는 배열의 특성 때문에 이렇게 처리가 가능하다.
  
# ✔️ String 배열
```java
String[] name = new String[3];
```
- 참조형 변수의 기본값은 null이므로 각 요소의 값은 null로 초기화 된다.
- 기본형 배열이 아닌 참조형 배열의 경우 배열에 저장되는 것은 객체의 주소이다.
- 참조형 변수 = 참조 변수 에는 메모리에 저장된 객체의 주소인 4 byte의 정수 값이나 null이 저장된다.

## 💡 char배열과 String 클래스
- 자바에서 char배열이 아닌 String 클래스를 이용해 문자열을 처리하는 이유는 String 클래스가 char배열에 여러 기능을 추가해 확장한 것이기 때문이다.
- 한번 생성된 String 객체(문자열)는 읽을 수만 있을 뿐 내용을 변경할 수 없다.
```java
String str = "hello";
str = str + " hi";
System.out.println(str);  //"hello hi"
```

![IMG_E82E9739CF61-1](https://user-images.githubusercontent.com/69254943/158023222-24166ad6-fbc0-44b1-8998-e7470dff3153.jpeg)
→ 위의 문장에서처럼 '+'연산자를 이용해 문자열을 결합하는 경우, 문자열 str의 내용이 변경된 것이 아니라 새로운 내용의 문자열이 생성된 것이다.   
→ 위와 같은 연산의 경우, 연산 시 마다 새로운 문자열을 가진 String인스턴스가 생성되어 메모리공간을 차지하게 되므로 결합횟수를 줄이는 것이 좋다.   
→ 문자열간의 결합이나 추출 등 문자열을 다루는 작업이 많이 필요한 경우 String클래스 대신 StringBuffer클래스를 사용하는 것이 좋다.   

## 💡 커맨드 라인을 통해 입력받기
- 프로그램 실행 시 클래스 이름 뒤에 공백문자로 구분하여 여러 개의 문자열을 프로그램에 전달할 수 있다.
```java
class Main {
  public static void main(String[] args) {
    System.out.println("매개변수의 개수: " + args.length);
  }
}
```
```bash
$ java Main abc 123
매개변수의 개수: 2
```
- 커맨드라인에 매개변수를 입력하지 않으면 크기가 0인 배열이 생성되어 args.length의 값은 0이 된다.
- 만약 입력된 매개변수가 없다고 해서 args 배열이 생성되지 않으면 참조변수 args의 값은 null이 될 것이고, 배열 args를 사용하는 모든 코드에서 에러가 발생할 것이다.
- 이를 대비해 JVM이 입력된 매개변수가 없을 때, null 대신 크기가 0인 배열을 생성해서 args에 전달하도록 구현되어있다.






