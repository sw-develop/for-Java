# ✔️ 컬렉션 프레임워크
- 컬렉션 프레임워크는 '데이터를 저장하는 클래스들을 표준화한 설계'를 뜻한다.

## ▶️ 컬렉션 프레임워크의 핵심 인터페이스

### #️⃣ 인터페이스간 상속계층도 
<img width="484" alt="image" src="https://user-images.githubusercontent.com/69254943/163675652-1f6e0516-1506-40ed-82e5-db6219b7d673.png">

- 인터페이스 List와 Set의 공통된 부분을 뽑아 Collection 인터페이스를 정의했다.
- Map 인터페이스는 다른 형태로 컬렉션을 다루기 때문에 같은 상속계층도에 포함하지 않았다.

### #️⃣ 핵심 인터페이스와 특징
- List
    - 순서가 있는 데이터의 집합
    - 데이터의 중복을 허용
    - 구현클래스 : ArrayList, LinkedList, Stack, Vector 등
    
- Set
    - 순서를 유지하지 않는 데이터의 집합
    - 데이터의 중복 허용 X
    - 구현클래스 : HastSet, TreeSet 등
    
- Map
    - Key와 Value의 쌍으로 이루어진 데이터의 집합
    - 순서가 유지되지 않음
    - 키는 중복 허용 X, 값은 중복 허용
    - 기존에 저장된 데이터와 중복된 키와 값을 저장하면 기존의 값은 없어지고, 마지막에 저장된 값이 남음
    - 구현클래스 : HashMap, TreeMap, Hashtable, Properties 등


→ Vector, Stack, HashTable, Properties 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이어서 컬렉션 프레임워크의 명명법을 따르지 않는다.

→ Vector나 HashTable 같은 기존의 컬렉션 클래스들은 호환을 위해, 설계를 변경해서 남겨두었지만 사용하지 않는 것이 좋다. 새로 추가된 다른 구현 클래스를 사용하자.



## ▶️ List 인터페이스 구현 클래스
### #️⃣️ ArrayList
- List 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고 중복을 허용한다.
- 기존의 Vector를 개선한 것으로 Vector와 구현원리와 기능적인 측면에서는 동일하므로, Vector 보다는 ArrayList를 사용하자.
- ArrayList는 Object 배열을 이용해 데이터를 순차적으로 저장한다.
    - 배열에 더 이상 저장할 공간이 없으면 큰 새로운 배열을 생성해서 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장되므로 효율이 떨어진다.
    - 배열의 타입이 Object이므로, 모든 종류의 객체를 담을 수 있다.
    

- 배열의 단점
    1. 크기를 변경할 수 없다.
        - 크기를 변경하려면, 새로운 배열을 생성해 데이터를 복사해야 한다.
        - 실행속도 향상을 위해 충분히 큰 크기의 배열을 생성하면 메모리가 낭비된다.
    2. 비순차적인 데이터의 추가 or 삭제에 시간이 많이 걸린다.
        - 순차적인 데이터의 추가 및 삭제는 빠르지만, 비순차적인 경우 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 한다.


### #️⃣ LinkedList
- List 인터페이스를 구현한 클래스로, 배열의 단점을 보완하기 위한 연결 리스트 자료구조를 사용한다.
     - Java의 LinkedList 클래스는 이중 연결 리스트로 구현되어 원소간 접근성을 높였다.
    


### #️⃣ 두 구현 클래스 비교
- ArrayList
    - 읽기가 빠르다. (인덱스로 접근하는 경우)
    - 순차적인 추가, 삭제는 빠르지만 비순차적인 추가, 삭제는 느리다.
    - 배열의 크기로 인해 비효율적인 메모리 사용이 된다.
    
- LinkedList
    - 읽기가 느리다. (각 요소들이 참조로 연결된 것이라 처음부터 n번째 데이터까지 차례대로 따라가야 함)
    - 추가, 삭제가 빠르다.
    - 데이터가 많을수록 접근성이 떨어진다.
    


## ▶️ Stack과 Queue
- Stack(스택) 구현
    - LIFO(Last In First Out) 구조로 ArrayList와 같은 배열 기반의 컬렉션 클래스를 사용한다.
    - 구현클래스 : Stack 클래스
    
- Queue(큐) 구현
    - 데이터의 추가/삭제가 쉬운 LinkedList 클래스로 구현하는 것이 적합하다.
        - 배열기반의 컬렉션 클래스를 사용한다면, 데이터를 꺼낼 때마다 빈 공간을 채우기 위해 데이터의 복사가 발생하므로 비효율적이다.
    - 구현클래스 : Queue는 인터페이스로만 정의해 놓아서 여러 구현 클래스 중에서 선택해 사용한다.
    

## ▶️ Comparator와 Comparable
- 모두 인터페이스로, 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있다.

```java
public interface Comparator {
  int compare(Object o1, Object o2);
  boolean equals(Object obj);
}

public interface Comparable {
  public int compareTo(Object o);
}
```
- Comparator : 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용
- Comparable : 기본 정렬기준(오름차순, 내림차순)을 구현하는데 사용



## ▶️ Set 인터페이스 구현 클래스 

### #️⃣ HashSet
- Set 인터페이스를 구현한 컬렉션으로, Set의 특징대로 중복된 요소를 저장하지 않는다.
- 저장순서를 유지하지 않으므로, 저장순서를 유지하고자 한다면 LinkedHashSet을 사용해야 한다.
- 내부적으로 HashMap을 이용해 만들어졌으며, 해싱(Hashing)을 이용해 구현했기 때문에 HashSet이다.

### #️⃣ TreeSet
- Set 인터페이스를 구현한 컬렉션으로, 이진 검색 트리(binary search tree) 자료구조의 형태로 데이터를 저장하는 클래스이다.
  - TreeSet은 이진 검색 트리의 성능을 향상시킨 '레드-블랙 트리(red-black tree)'로 구현되어 있다.
  - 중복된 데이터의 저장 허용 X
- 정렬, 검색, 범위 검색(range search)에 높은 성능을 가진다.
    - 데이터의 추가/삭제 시에는 저장위치를 찾아서 저장해야 하고, 트리의 일부를 재구성해야하므로 링크드 리스트보다는 시간이 오래 걸린다.
- 정렬된 위치에 저장하지만(이진 검색 트리의 특징), 순서를 보장하지 않는다.
  - TreeSet에 저장되는 객체가 Comparable 인터페이스를 구현하던가, Comparator를 제공(TreeSet의 생성자에 전달)해서 객체를 비교할 방법을 알려줘야 한다.



## ▶️ Map 인터페이스 구현 클래스

### #️⃣ HashMap
- HashTable은 Collection 이전의 클래스이므로, HashMap을 사용하자.
- Map 인터페이스를 구현했으므로 Map의 특징인 (Key, Value)를 묶어서 하나의 데이터로 저장한다.
- 해싱(Hashing)을 사용해 데이터를 저장하고 검색하므로, 검색 성능이 좋다.
- null을 허용하므로, map.put(null, null); map.get(null); 이 가능하다.

### 💡 해싱과 해시함수
- 해싱
  - 해시함수를 이용해 데이터를 해시테이블에 저장하고 검색하는 기법이다.
  - 해싱에서 사용하는 자료구조는 아래 예시와 같이 배열 & 링크드 리스트의 조합이다.
  - 저장할 데이터의 키를 해시함수에 넣으면, 해시코드를 반환하고, 해당 배열의 요소에 연결되어 있는 링크드 리스트에 저장한다.
    - **배열의 인덱스가 n인 요소의 주소 = 배열의 시작주소 + type의 size * n** 공식을 사용해 배열에 빠른 접근이 가능하다.  
- 해시코드의 성능
  - 하나의 링크드 리스트에 최소한의 데이터만 저장되려면, 해시함수가 서로 다른 키에 대해 중복된 해시코드의 반환을 최소화해야 한다. (빠른 검색 성능을 위해서)
  - HashMap과 같이 해싱을 구현한 컬렉션 클래스에서는 Object 클래스에 정의된 hashCode()를 해시함수로 이용한다.
    - 해당 메서드는 객체의 주소를 이용하는 알고리즘으로 해시코드를 생성한다.

예제) HashMap에 저장된 데이터를 찾는 과정
<img width="576" alt="image" src="https://user-images.githubusercontent.com/69254943/163695707-e76c0329-8a50-4b7d-8389-abe013730b57.png">

1) 검색하고자 하는 값의 키로 해시함수를 호출한다.
2) 해시함수의 계산결과(해시코드)로 해당 값이 저장되어 있는 링크드 리스트를 찾는다.
3) 링크드 리스트에서 검색한 키와 일치하는 데이터를 찾는다.



## ▶️ Collections
- Arrays가 배열과 관련된 메서드를 제공하는 것처럼, Collections 클래스는 컬렉션과 관련된 메서드를 제공한다.
  - fill(), copy(), sort(), binarySearch() 등의 메소드를 제공한다.
  
- 추가 제공 기능
  - 컬렉션의 동기화
    - 동기화가 필요할 때 Collections 클래스의 동기화 메서드를 사용한다.
  - 변경불가 컬렉션 만들기
    - 컬렉션에 저장된 데이터 보호를 위해 컬렉션을 읽기전용으로 만들어야할 때 사용한다.
  - 싱글톤 컬렉션 만들기
    - 인스턴스를 new 연산자가 아닌 메서드를 통해서만 1개 생성할 수 있도록 한다.
  - 한 종류의 객체만 저장하는 컬렉션 만들기
    - 컬렉션에 지정된 종류의 객체만 저장하도록 제한한다.
    - Collections에서 제공하는 메서드 대신 제네릭을 사용할 수 있다. (제네릭 이전 버전의 호환성을 위해 제공된 메서드들임)











