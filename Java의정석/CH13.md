# ✔️ 쓰레드

## 1. 프로세스와 쓰레드
- 프로세스
    - 실행중인 프로그램
    - 프로그램을 실행하면 OS로부터 실행에 필요한 자원(메모리)을 할당받아 프로세스가 된다.
    
- 쓰레드
    - 프로세스의 자원을 이용해서 실제로 작업을 수행하는 것
    - 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재한다.
    - 쓰레드가 작업을 수행하려면 개별적인 메모리 공간(호출스택)이 필요하다.
    - CPU의 코어가 한 번에 단 하나의 작업만 수행할 수 있으므로, 동시 처리되는 작업의 수 == 코어의 개수 이다.

## 2. Java에서 쓰레드의 구현과 실행
- 쓰레드를 구현하는 방법 2가지
    - Thread 클래스 상속 or Runnable 인터페이스 구현
    - Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없기 때문에, Runnable 인터페이스를 구현하는 방법이 일반적이다.
    
### #️⃣ Thread 클래스 상속
```java
class MyThread extends Thread {
  @Override
  public void run() { //Thread 클래스의 run() 오버라이딩
    //작업 내용 
  }
}
```

### #️⃣ Runnable 인터페이스 구현
```java
public class MyThread implements Runnable {
  public void run() { /*작업내용*/ }  
}
```

- 쓰레드를 구현한다는 것은 위의 2가지 방식 모두, 쓰레드를 통해 수행하고자 하는 작업 내용으로 run()의 메서드를 구현하는 것이다.

### #️⃣ 인스턴스 생성 방법
- Thread 클래스 상속
```java
class ThreadA extends Thread {
  @Override
  public void run() {
    System.out.println(getName());  //Thread의 getName()
  }
}
//인스턴스 생성 
ThreadA t1 = new ThreadA();
```
→ Thread 클래스를 상속받아 구현하면, 자손 클래스에서 Thread 클래스의 run()을 직접 호출할 수 있다.

- Runnable 인터페이스 구현
```java
class ThreadB implements Runnable {
  public void run() {
    System.out.println(Thread.currentThread().getName());
  }
}
//인스턴스 생성
Runnable r = new ThreadB(); //Runnable을 구현한 클래스의 인스턴스 생성  
Thread t2 = Thread(r);  //Thread 클래스의 생성자로 전달
    
Thread t3 = Thread(new ThreadB());  //한 줄로
```
→ Runnable 인터페이스 구현하면, Thread 클래스의 static 메서드인 currentThread()로 현재 실행중인 쓰레드의 참조를 얻어 와야 호출이 가능하다.

### #️⃣ 쓰레드의 실행
- 쓰레드 인스턴스를 생성했다고 자동을 실행되지 않고, start()를 호출해야 쓰레드가 실행된다.
- start()를 호출하면, 실행대기 상태에 있다가 자신의 차례가 되어야 실행된다.
  - 실행대기중인 쓰레드가 하나도 없으면 곧바로 실행
  
- 쓰레드의 실행 순서는 OS의 스케쥴러가 작성한 스케쥴에 의해 결정된다.
- 한 번 실행이 종료된 쓰레드(인스턴스)는 다시 실행할 수 없다.
  - 새로운 쓰레드 인스턴스를 생성한 뒤 다시 start()를 호출해야 함
  
### #️⃣ start()와 run()
- main 메서드에서 run()을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아니라, 단순히 클래스에 선언된 메서드를 호출하는 것 뿐이다.
- start() : 새로운 쓰레드를 위해 호출스택(call stack)을 생성한 후 run()을 호출해서, 생성된 호출스택에 run()이 첫 번째로 올라가게 한다.
  1) main 메서드에서 쓰레드의 start() 호출
  2) start()는 새로운 쓰레드를 생성하고, 쓰레드가 작업하는데 사용될 호출스택 생성
  3) 새로 생성된 호출스택에 run()이 호출되어, 쓰레드가 독립된 공간에서 작업을 수행
  4) 호출스택이 2개가 되었으므로 스케쥴러가 정한 순서에 의해 번갈아 가면서 실행
  
- 주어진 시간동안 작업을 마치지 못한 쓰레드는 다시 자신의 차례가 될 때까지 대기 상태로 있는다.
- 작업을 마친 쓰레드(= run()의 수행이 종료된 쓰레드)는 사용하던 호출스택이 모두 비워지고 삭제된다.
  - 자바프로그램 실행시 호출스택이 생성되고, main메서드가 처음으로 호출되고, main메서드 종료되면 호출스택이 비워지면서 프로그램이 종료되는 것과 같음
  
- 한 쓰레드에서 예외가 발생해 종료되어도 다른 쓰레드의 실행에 영향을 미치지 않는다.

## 3. 쓰레드의 우선순위
- 쓰레드는 우선순위(priority)라는 속성을 가지고 있고, 이 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라진다.
- 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있다.
  - ex) 시각적인 부분이나 사용자에게 빠르게 반응해야 하는 작업을 하는 쓰레드의 우선순위를 높게 한다.

### #️⃣ 쓰레드의 우선순위 지정하기
```java
void setPriority(int newPriority) //쓰레드의 우선순위를 지정한 값으로 변경
int getPriority() //쓰레드의 우선순위 반환
```
- 쓰레드가 가질 수 있는 우선순위의 범위는 1~10이며 숫자가 높을수록 우선순위가 높다.
- 쓰레드의 우선순위는 default로 해당 쓰레드를 생성한 쓰레드로부터 상속받는다.
  - ex) main메서드를 실행하는 쓰레드 우선순위는 5이므로, main메서드 내에서 생성하는 쓰레드의 우선순위는 자동적으로 5이다.
  
#### 추가 내용 참고 
- https://codedragon.tistory.com/5346

## 4. 쓰레드 그룹(thread group)
- 쓰레드 그룹은 서로 관련된 쓰레드를 그룹으로 다루기 위한 것으로, 쓰레드 그룹을 생성해서 쓰레드를 그룹으로 묶어서 관리한다.
- 쓰레드 그룹 내에 다른 쓰레드 그룹을 포함시킬 수 있다.
- 해당 개념은 보안상의 이유로 도입되었다.
  - 자신이 속한 쓰레드 그룹 or 하위 쓰레드 구릅운 변경 가능하지만, 다른 쓰레드 그룹의 쓰레드는 변경할 수 없다.
  
- 모든 쓰레드는 반드시 쓰레드 그룹에 포함되어 있어야 하기 때문에, 쓰레드 그룹을 지정하지 않은 경우 기본적으로 자신을 생성한 쓰레드와 같은 쓰레드 그룹에 속한다.
- 자바 어플리케이션 실행시, JVM은 main과 system 2가지 쓰레드 그룹을 생성한다.
  - 사용자가 생성하는 모든 쓰레드 그룹은 main 쓰레드 그룹의 하위 쓰레드 그룹에 속한다.
  
## 5. 데몬 쓰레드(daemon thread)
- 데몬 쓰레드는 다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 수행하는 쓰레드이다.
  - 데몬 쓰레드가 생성한 쓰레드는 자동적으로 데몬 쓰레드가 된다.
- 무한루프와 조건문을 이용해 실행 후 대기하고 있다가 특정 조건이 만족되면 작업을 수행하고 다시 대기하도록 작성한다.
- 프로그램 실행시, JVM은 가비지컬렉션, 이벤트처리, 그래픽처리 같은 프로그램 실행에 필요한 보조 작업을 수행하는 데몬 쓰레드들을 자동적으로 생성해 실행시킨다.
  - 해당 쓰레드들은 system 혹은 main 쓰레드 그룹에 속한다.

## 6. 쓰레드의 실행제어 ✨
### #️⃣ 쓰레드의 상태
- NEW : 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태
- RUNNABLE : 실행중 or 실행 가능한 상태
- BLOCKED : 동기화블럭에 의해 일시정지된 상태(lock이 풀릴 때까지 기다리는 상태)
- WAITING, TIMED_WAITING : 쓰레드의 작업이 종료되진 않았지만, 실행가능하지 않은 일시정지 상태 (TIMED_WAITING은 일시정지시간이 지정된 경우)
- TERMINATED : 쓰레드의 작업이 종료된 상태

<img width="930" alt="image" src="https://user-images.githubusercontent.com/69254943/166127177-5905d70b-a4c2-4624-8fe3-646ac919bd8a.png">

### #️⃣ 관련 메서드 정리
https://ryan-han.com/post/dev/java-thread/

## 7. 쓰레드의 동기화 ✨
- 멀티 쓰레드의 경우 여러 쓰레드가 동일한 프로세스 내의 자원을 공유해서 작업하기 때문에 서로 영향을 주게 된다.
- 이를 위해 도입된 개념이 '임계영역(critical section)'과 '잠금(Lock)'이다.
  - 공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정
  - 공유 데이터(객체)가 가지고 있는 lock을 획득한 단 하나의 쓰레드만 해당 영역 내의 코드를 수행
  - 해당 쓰레드가 임계 영역 내의 모든 코드를 수행하고 벗어나서 lock을 반환
  - 다른 쓰레드가 반납된 lock을 획득해 임계 영역의 코드를 수행
  
- '쓰레드 동기화(synchronization)'는 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것이다.
  - 구현 방식
    - synchronized 블록
    - 'java.util.concurrent.locks'와 'java.util.concurrent.atomic' 패키지 사용 (JDK 1.5부터)

### #️⃣ synchronized를 이용한 동기화
```java
//1. 메서드 전체를 임계 영역으로 지정
public synchronized void calcSum() {...}

//2. 특정한 영역을 임계 영역으로 지정
public void calcSum() {
  synchronized(this) {...}  
}
```
- synchronized가 호출된 시점부터 해당 임계 영역을 포함한 객체의 lock을 얻어 작업 수행 후 lock을 반환한다.
  - lock의 획득과 반납으로 자동으로 이루어짐
- 임계 영역은 멀티 쓰레드 프로그램의 성능에 영향을 끼치기 때문에 메서드 전체 lock보다 임계 영역을 최소화하는 것이 좋다.

#### 추가 내용 참고
- https://www.hyojae.info/4d4fb935-8314-4f32-905f-75edbf0c35a2


